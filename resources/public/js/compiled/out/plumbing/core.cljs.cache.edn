;; Analyzed by ClojureScript 0.0-3126
{:use-macros {if-cljs schema.macros, lazy-get plumbing.core, for-map plumbing.core, -unless-update plumbing.core}, :excludes #{update}, :macros {as->> {:ns plumbing.core, :name plumbing.core/as->>, :file "plumbing/core.clj", :column 1, :line 338, :macro true, :arglists ([name & forms-and-expr]), :doc "Like as->, but can be used in double arrow."}, ?>> {:ns plumbing.core, :name plumbing.core/?>>, :file "plumbing/core.clj", :column 1, :line 304, :macro true, :arglists ([do-it? & args]), :doc "Conditional double-arrow operation (->> nums (?>> inc-all? (map inc)))"}, if-letk {:ns plumbing.core, :name plumbing.core/if-letk, :file "plumbing/core.clj", :column 1, :line 427, :macro true, :arglists ([bindings then] [bindings then else]), :doc "bindings => binding-form test\n\n  If test is true, evaluates then with binding-form bound to the value of\n  test, if not, yields else"}, fnk {:ns plumbing.core, :name plumbing.core/fnk, :file "plumbing/core.clj", :column 1, :line 451, :macro true, :arglists ([& args]), :doc "Keyword fn, using letk.  Generates a prismatic/schema schematized fn that\n   accepts a single explicit map i.e., (f {:foo :bar}).\n\n   Explicit top-level map structure will be recorded in output spec, or\n   to capture implicit structure use an explicit prismatic/schema hint on the\n   function name.\n\n   Individual inputs can also be schematized by putting :- schemas after the\n   binding symbol.  Schemas can also be used on & more symbols to describe\n   additional map inputs, or on entire [] bindings to override the automatically\n   generated schema for the contents (caveat emptor).\n\n   By default, input schemas allow for arbitrary additional mappings\n   ({s/Keyword s/Any}) unless explicit binding or & more schemas are provided."}, defnk {:ns plumbing.core, :name plumbing.core/defnk, :file "plumbing/core.clj", :column 1, :line 473, :macro true, :arglists ([& defnk-args]), :doc "Analogy: fn:fnk :: defn::defnk"}, memoized-fn {:ns plumbing.core, :name plumbing.core/memoized-fn, :file "plumbing/core.clj", :column 1, :line 343, :macro true, :arglists ([name args & body]), :doc "Like fn, but memoized (including recursive calls).\n\n   The clojure.core memoize correctly caches recursive calls when you do a top-level def\n   of your memoized function, but if you want an anonymous fibonacci function, you must use\n   memoized-fn rather than memoize to cache the recursive calls."}, <- {:ns plumbing.core, :name plumbing.core/<-, :file "plumbing/core.clj", :column 1, :line 328, :macro true, :arglists ([& body]), :doc "Converts a ->> to a ->\n\n   (->> (range 10) (map inc) (<- (doto prn)) (reduce +))\n\n   Jason W01fe is happy to give a talk anywhere any time on\n   the calculus of arrow macros"}, when-letk {:ns plumbing.core, :name plumbing.core/when-letk, :file "plumbing/core.clj", :column 1, :line 444, :macro true, :arglists ([bindings & body]), :doc "bindings => binding-form test\n\n  When test is true, evaluates body with binding-form bound to the value of test"}, lazy-get {:ns plumbing.core, :name plumbing.core/lazy-get, :file "plumbing/core.clj", :column 1, :line 120, :macro true, :arglists ([m k d]), :doc "Like get but lazy about default"}, fn-> {:ns plumbing.core, :name plumbing.core/fn->, :file "plumbing/core.clj", :column 1, :line 318, :macro true, :arglists ([& body]), :doc "Equivalent to `(fn [x] (-> x ~@body))"}, letk {:ns plumbing.core, :name plumbing.core/letk, :file "plumbing/core.clj", :column 1, :line 393, :macro true, :arglists ([bindings & body]), :doc "Keyword let.  Accepts an interleaved sequence of binding forms and map forms like:\n   (letk [[a {b 2} [:f g h] c d {e 4} :as m & more] a-map ...] & body)\n   a, c, d, and f are required keywords, and letk will barf if not in a-map.\n   b and e are optional, and will be bound to default values if not present.\n   g and h are required keys in the map found under :f.\n   m will be bound to the entire map (a-map).\n   more will be bound to all the unbound keys (ie (dissoc a-map :a :b :c :d :e)).\n   :as and & are both optional, but must be at the end in the specified order if present.\n   The same symbol cannot be bound multiple times within the same destructing level.\n\n   Optional values can reference symbols bound earlier within the same binding, i.e.,\n   (= [2 2] (let [a 1] (letk [[a {b a}] {:a 2}] [a b]))) but\n   (= [2 1] (let [a 1] (letk [[{b a} a] {:a 2}] [a b])))\n\n   If present, :as and :& symbols are bound before other symbols within the binding.\n\n   Namespaced keys are supported by specifying fully-qualified key in binding form. The bound\n   symbol uses the _name_ portion of the namespaced key, i.e,\n   (= 1 (letk [[a/b] {:a/b 1}] b))"}, for-map {:ns plumbing.core, :name plumbing.core/for-map, :file "plumbing/core.clj", :column 1, :line 22, :macro true, :arglists ([seq-exprs key-expr val-expr] [m-sym seq-exprs key-expr val-expr]), :doc "Like 'for' for building maps. Same bindings except the body should have a\n  key-expression and value-expression. If a key is repeated, the last\n  value (according to \"for\" semantics) will be retained.\n\n  (= (for-map [i (range 2) j (range 2)] [i j] (even? (+ i j)))\n     {[0 0] true, [0 1] false, [1 0] false, [1 1] true})\n\n  An optional symbol can be passed as a first argument, which will be\n  bound to the transient map containing the entries produced so far."}, ?> {:ns plumbing.core, :name plumbing.core/?>, :file "plumbing/core.clj", :column 1, :line 311, :macro true, :arglists ([arg do-it? & rest]), :doc "Conditional single-arrow operation (-> m (?> add-kv? (assoc :k :v)))"}, -unless-update {:ns plumbing.core, :name plumbing.core/-unless-update, :file "plumbing/core.clj", :column 1, :line 41, :macro true, :arglists ([body]), :doc "Execute and yield body only if Clojure version preceeds introduction\n  of 'update' into core namespace."}, fn->> {:ns plumbing.core, :name plumbing.core/fn->>, :file "plumbing/core.clj", :column 1, :line 323, :macro true, :arglists ([& body]), :doc "Equivalent to `(fn [x] (->> x ~@body))"}}, :name plumbing.core, :imports nil, :requires {schema plumbing.fnk.schema, plumbing.fnk.schema plumbing.fnk.schema, schema.utils schema.utils, schema-utils schema.utils}, :uses nil, :defs {dissoc-in {:protocol-inline nil, :meta {:arglists (quote ([m [k & ks]])), :doc "Dissociate this keyseq from m, removing any empty maps created as a result\n   (including at the top-level).", :end-column 16, :end-line 94, :column 7, :line 94, :file "/Users/adam/Copy/play/clj/outliner/resources/public/js/compiled/out/plumbing/core.cljs"}, :name plumbing.core/dissoc-in, :variadic false, :file "resources/public/js/compiled/out/plumbing/core.cljs", :end-column 16, :method-params ([m p__30723]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{clj clj-nil}, :variadic false, :max-fixed-arity 2}), :line 94, :end-line 94, :max-fixed-arity 2, :fn-var true, :arglists (quote ([m [k & ks]])), :doc "Dissociate this keyseq from m, removing any empty maps created as a result\n   (including at the top-level).", :test true}, rsort-by {:doc "Like sort-by, but prefers higher values rather than lower ones.", :meta {:end-column 14, :end-line 297, :column 6, :line 297, :file "/Users/adam/Copy/play/clj/outliner/resources/public/js/compiled/out/plumbing/core.cljs"}, :file "resources/public/js/compiled/out/plumbing/core.cljs", :line 297, :column 1, :end-line 297, :end-column 14, :test true, :name plumbing.core/rsort-by}, +none+ {:meta {:private true, :end-column 22, :end-line 15, :column 16, :line 15, :file "/Users/adam/Copy/play/clj/outliner/resources/public/js/compiled/out/plumbing/core.cljs"}, :private true, :name plumbing.core/+none+, :file "resources/public/js/compiled/out/plumbing/core.cljs", :end-column 22, :column 1, :line 15, :end-line 15, :doc "A sentinel value representing missing portions of the input data.", :test true}, millis {:protocol-inline nil, :meta {:arglists (quote ([])), :end-column 13, :end-line 380, :column 7, :line 380, :file "/Users/adam/Copy/play/clj/outliner/resources/public/js/compiled/out/plumbing/core.cljs"}, :name plumbing.core/millis, :variadic false, :file "resources/public/js/compiled/out/plumbing/core.cljs", :end-column 13, :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 0}), :line 380, :end-line 380, :max-fixed-arity 0, :fn-var true, :arglists (quote ([])), :test true}, swap-pair! {:protocol-inline nil, :meta {:arglists (quote ([a f] [a f & args])), :doc "Like swap! but returns a pair [old-val new-val]", :end-column 17, :end-line 363, :column 7, :line 363, :file "/Users/adam/Copy/play/clj/outliner/resources/public/js/compiled/out/plumbing/core.cljs"}, :name plumbing.core/swap-pair!, :variadic true, :file "resources/public/js/compiled/out/plumbing/core.cljs", :end-column 17, :method-params ([a f] [a f args]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/IVector, :variadic false, :max-fixed-arity 2} {:tag cljs.core/IVector, :variadic true, :max-fixed-arity 2}), :line 363, :end-line 363, :max-fixed-arity 2, :fn-var true, :arglists (quote ([a f] [a f & args])), :doc "Like swap! but returns a pair [old-val new-val]", :test true}, keywordize-map {:protocol-inline nil, :meta {:arglists (quote ([x])), :doc "Recursively convert maps in m (including itself)\n   to have keyword keys instead of string", :end-column 21, :end-line 105, :column 7, :line 105, :file "/Users/adam/Copy/play/clj/outliner/resources/public/js/compiled/out/plumbing/core.cljs"}, :name plumbing.core/keywordize-map, :variadic false, :file "resources/public/js/compiled/out/plumbing/core.cljs", :end-column 21, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil clj cljs.core/LazySeq}, :variadic false, :max-fixed-arity 1}), :line 105, :end-line 105, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Recursively convert maps in m (including itself)\n   to have keyword keys instead of string", :test true}, get-and-set! {:protocol-inline nil, :meta {:arglists (quote ([a new-val])), :doc "Like reset! but returns old-val", :end-column 19, :end-line 375, :column 7, :line 375, :file "/Users/adam/Copy/play/clj/outliner/resources/public/js/compiled/out/plumbing/core.cljs"}, :name plumbing.core/get-and-set!, :variadic false, :file "resources/public/js/compiled/out/plumbing/core.cljs", :end-column 19, :method-params ([a new-val]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{any clj-nil}, :variadic false, :max-fixed-arity 2}), :line 375, :end-line 375, :max-fixed-arity 2, :fn-var true, :arglists (quote ([a new-val])), :doc "Like reset! but returns old-val", :test true}, positions {:protocol-inline nil, :meta {:arglists (quote ([f s])), :doc "Returns indices idx of sequence s where (f (nth s idx))", :end-column 16, :end-line 212, :column 7, :line 212, :file "/Users/adam/Copy/play/clj/outliner/resources/public/js/compiled/out/plumbing/core.cljs"}, :name plumbing.core/positions, :variadic false, :file "resources/public/js/compiled/out/plumbing/core.cljs", :end-column 16, :method-params ([f s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 2}), :line 212, :end-line 212, :max-fixed-arity 2, :fn-var true, :arglists (quote ([f s])), :doc "Returns indices idx of sequence s where (f (nth s idx))", :test true}, sum {:protocol-inline nil, :meta {:arglists (quote ([f xs] [xs])), :doc "Return sum of (f x) for each x in xs", :end-column 10, :end-line 195, :column 7, :line 195, :file "/Users/adam/Copy/play/clj/outliner/resources/public/js/compiled/out/plumbing/core.cljs"}, :name plumbing.core/sum, :variadic false, :file "resources/public/js/compiled/out/plumbing/core.cljs", :end-column 10, :method-params ([f xs] [xs]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 2} {:tag any, :variadic false, :max-fixed-arity 1}), :line 195, :end-line 195, :max-fixed-arity 2, :fn-var true, :arglists (quote ([f xs] [xs])), :doc "Return sum of (f x) for each x in xs", :test true}, conj-when {:protocol-inline nil, :meta {:arglists (quote ([coll x] [coll x & xs])), :doc "Like conj but ignores non-truthy values", :end-column 16, :end-line 282, :column 7, :line 282, :file "/Users/adam/Copy/play/clj/outliner/resources/public/js/compiled/out/plumbing/core.cljs"}, :name plumbing.core/conj-when, :variadic true, :file "resources/public/js/compiled/out/plumbing/core.cljs", :end-column 16, :method-params ([coll x] [coll x xs]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil clj}, :variadic false, :max-fixed-arity 2} {:tag #{nil clj}, :variadic true, :max-fixed-arity 2}), :line 282, :end-line 282, :max-fixed-arity 2, :fn-var true, :arglists (quote ([coll x] [coll x & xs])), :doc "Like conj but ignores non-truthy values", :test true}, distinct-by {:protocol-inline nil, :meta {:arglists (quote ([f xs])), :doc "Returns elements of xs which return unique\n   values according to f. If multiple elements of xs return the same\n   value under f, the first is returned", :end-column 18, :end-line 237, :column 7, :line 237, :file "/Users/adam/Copy/play/clj/outliner/resources/public/js/compiled/out/plumbing/core.cljs"}, :name plumbing.core/distinct-by, :variadic false, :file "resources/public/js/compiled/out/plumbing/core.cljs", :end-column 18, :method-params ([f xs]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 2}), :line 237, :end-line 237, :max-fixed-arity 2, :fn-var true, :arglists (quote ([f xs])), :doc "Returns elements of xs which return unique\n   values according to f. If multiple elements of xs return the same\n   value under f, the first is returned", :test true}, safe-get-in {:protocol-inline nil, :meta {:arglists (quote ([m ks])), :doc "Like get-in but throws exception if not found", :end-column 18, :end-line 134, :column 7, :line 134, :file "/Users/adam/Copy/play/clj/outliner/resources/public/js/compiled/out/plumbing/core.cljs"}, :name plumbing.core/safe-get-in, :variadic false, :file "resources/public/js/compiled/out/plumbing/core.cljs", :end-column 18, :method-params ([m ks]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:variadic false, :max-fixed-arity 2}), :line 134, :end-line 134, :max-fixed-arity 2, :fn-var true, :arglists (quote ([m ks])), :doc "Like get-in but throws exception if not found", :test true}, indexed {:protocol-inline nil, :meta {:arglists (quote ([s])), :doc "Returns [idx x] for x in seqable s", :end-column 14, :end-line 207, :column 7, :line 207, :file "/Users/adam/Copy/play/clj/outliner/resources/public/js/compiled/out/plumbing/core.cljs"}, :name plumbing.core/indexed, :variadic false, :file "resources/public/js/compiled/out/plumbing/core.cljs", :end-column 14, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 1}), :line 207, :end-line 207, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s])), :doc "Returns [idx x] for x in seqable s", :test true}, cons-when {:protocol-inline nil, :meta {:arglists (quote ([x s])), :doc "Like cons but does nothing if x is non-truthy.", :end-column 16, :end-line 292, :column 7, :line 292, :file "/Users/adam/Copy/play/clj/outliner/resources/public/js/compiled/out/plumbing/core.cljs"}, :name plumbing.core/cons-when, :variadic false, :file "resources/public/js/compiled/out/plumbing/core.cljs", :end-column 16, :method-params ([x s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil cljs.core/Cons}, :variadic false, :max-fixed-arity 2}), :line 292, :end-line 292, :max-fixed-arity 2, :fn-var true, :arglists (quote ([x s])), :doc "Like cons but does nothing if x is non-truthy.", :test true}, mapply {:protocol-inline nil, :meta {:arglists (quote ([f m] [f arg & args])), :doc "Like apply, but applies a map to a function with positional map\n  arguments. Can take optional initial args just like apply.", :end-column 13, :end-line 384, :column 7, :line 384, :file "/Users/adam/Copy/play/clj/outliner/resources/public/js/compiled/out/plumbing/core.cljs"}, :name plumbing.core/mapply, :variadic true, :file "resources/public/js/compiled/out/plumbing/core.cljs", :end-column 13, :method-params ([f m] [f arg args]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag any, :variadic false, :max-fixed-arity 2} {:tag any, :variadic true, :max-fixed-arity 2}), :line 384, :end-line 384, :max-fixed-arity 2, :fn-var true, :arglists (quote ([f m] [f arg & args])), :doc "Like apply, but applies a map to a function with positional map\n  arguments. Can take optional initial args just like apply.", :test true}, map-keys {:protocol-inline nil, :meta {:arglists (quote ([f m])), :doc "Build map (f k) -> v for [k v] in map m", :end-column 15, :end-line 77, :column 7, :line 77, :file "/Users/adam/Copy/play/clj/outliner/resources/public/js/compiled/out/plumbing/core.cljs"}, :name plumbing.core/map-keys, :variadic false, :file "resources/public/js/compiled/out/plumbing/core.cljs", :end-column 15, :method-params ([f m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag clj, :variadic false, :max-fixed-arity 2}), :line 77, :end-line 77, :max-fixed-arity 2, :fn-var true, :arglists (quote ([f m])), :doc "Build map (f k) -> v for [k v] in map m", :test true}, interleave-all {:protocol-inline nil, :meta {:arglists (quote ([& colls])), :doc "Analogy: partition:partition-all :: interleave:interleave-all", :end-column 21, :end-line 267, :column 7, :line 267, :file "/Users/adam/Copy/play/clj/outliner/resources/public/js/compiled/out/plumbing/core.cljs"}, :name plumbing.core/interleave-all, :variadic true, :file "resources/public/js/compiled/out/plumbing/core.cljs", :end-column 21, :method-params ([colls]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/LazySeq, :variadic true, :max-fixed-arity 0}), :line 267, :end-line 267, :max-fixed-arity 0, :fn-var true, :arglists (quote ([& colls])), :doc "Analogy: partition:partition-all :: interleave:interleave-all", :test true}, update {:protocol-inline nil, :meta {:arglists (quote ([m k f] [m k f x1] [m k f x1 x2] [m k f x1 x2 & xs])), :doc "Updates the value in map m at k with the function f.\n\n    Like update-in, but for updating a single top-level key.\n    Any additional args will be passed to f after the value.\n\n    WARNING As of Clojure 1.7 this function exists in clojure.core and\n    will not be exported by this namespace.", :end-column 14, :end-line 53, :column 8, :line 53, :file "/Users/adam/Copy/play/clj/outliner/resources/public/js/compiled/out/plumbing/core.cljs"}, :name plumbing.core/update, :variadic true, :file "resources/public/js/compiled/out/plumbing/core.cljs", :end-column 14, :method-params ([m k f] [m k f x1] [m k f x1 x2] [m k f x1 x2 xs]), :protocol-impl nil, :arglists-meta (nil nil), :column 2, :methods ({:tag clj, :variadic false, :max-fixed-arity 3} {:tag clj, :variadic false, :max-fixed-arity 4} {:tag clj, :variadic false, :max-fixed-arity 5} {:tag clj, :variadic true, :max-fixed-arity 5}), :line 53, :end-line 53, :max-fixed-arity 5, :fn-var true, :arglists (quote ([m k f] [m k f x1] [m k f x1 x2] [m k f x1 x2 & xs])), :doc "Updates the value in map m at k with the function f.\n\n    Like update-in, but for updating a single top-level key.\n    Any additional args will be passed to f after the value.\n\n    WARNING As of Clojure 1.7 this function exists in clojure.core and\n    will not be exported by this namespace.", :test true}, grouped-map {:protocol-inline nil, :meta {:arglists (quote ([key-fn map-fn coll])), :doc "Like group-by, but accepts a map-fn that is applied to values before\n   collected.", :end-column 18, :end-line 158, :column 7, :line 158, :file "/Users/adam/Copy/play/clj/outliner/resources/public/js/compiled/out/plumbing/core.cljs"}, :name plumbing.core/grouped-map, :variadic false, :file "resources/public/js/compiled/out/plumbing/core.cljs", :end-column 18, :method-params ([key-fn map-fn coll]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag clj, :variadic false, :max-fixed-arity 3}), :line 158, :end-line 158, :max-fixed-arity 3, :fn-var true, :arglists (quote ([key-fn map-fn coll])), :doc "Like group-by, but accepts a map-fn that is applied to values before\n   collected.", :test true}, count-when {:protocol-inline nil, :meta {:arglists (quote ([pred xs])), :doc "Returns # of elements of xs where pred holds", :end-column 17, :end-line 277, :column 7, :line 277, :file "/Users/adam/Copy/play/clj/outliner/resources/public/js/compiled/out/plumbing/core.cljs"}, :name plumbing.core/count-when, :variadic false, :file "resources/public/js/compiled/out/plumbing/core.cljs", :end-column 17, :method-params ([pred xs]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag number, :variadic false, :max-fixed-arity 2}), :line 277, :end-line 277, :max-fixed-arity 2, :fn-var true, :arglists (quote ([pred xs])), :doc "Returns # of elements of xs where pred holds", :test true}, aconcat {:protocol-inline nil, :meta {:arglists (quote ([s])), :doc "Like (apply concat s) but lazier (and shorter) ", :end-column 14, :end-line 173, :column 7, :line 173, :file "/Users/adam/Copy/play/clj/outliner/resources/public/js/compiled/out/plumbing/core.cljs"}, :name plumbing.core/aconcat, :variadic false, :file "resources/public/js/compiled/out/plumbing/core.cljs", :end-column 14, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag cljs.core/LazySeq, :variadic false, :max-fixed-arity 1}), :line 173, :end-line 173, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s])), :doc "Like (apply concat s) but lazier (and shorter) ", :test true}, singleton {:protocol-inline nil, :meta {:arglists (quote ([xs])), :doc "returns (first xs) when xs has only 1 element", :end-column 16, :end-line 200, :column 7, :line 200, :file "/Users/adam/Copy/play/clj/outliner/resources/public/js/compiled/out/plumbing/core.cljs"}, :name plumbing.core/singleton, :variadic false, :file "resources/public/js/compiled/out/plumbing/core.cljs", :end-column 16, :method-params ([xs]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{any clj-nil}, :variadic false, :max-fixed-arity 1}), :line 200, :end-line 200, :max-fixed-arity 1, :fn-var true, :arglists (quote ([xs])), :doc "returns (first xs) when xs has only 1 element", :test true}, map-from-keys {:protocol-inline nil, :meta {:arglists (quote ([f ks])), :doc "Build map k -> (f k) for keys in ks", :end-column 20, :end-line 84, :column 7, :line 84, :file "/Users/adam/Copy/play/clj/outliner/resources/public/js/compiled/out/plumbing/core.cljs"}, :name plumbing.core/map-from-keys, :variadic false, :file "resources/public/js/compiled/out/plumbing/core.cljs", :end-column 20, :method-params ([f ks]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag clj, :variadic false, :max-fixed-arity 2}), :line 84, :end-line 84, :max-fixed-arity 2, :fn-var true, :arglists (quote ([f ks])), :doc "Build map k -> (f k) for keys in ks", :test true}, map-vals {:protocol-inline nil, :meta {:arglists (quote ([f m])), :doc "Build map k -> (f v) for [k v] in map, preserving the initial type", :end-column 15, :end-line 66, :column 7, :line 66, :file "/Users/adam/Copy/play/clj/outliner/resources/public/js/compiled/out/plumbing/core.cljs"}, :name plumbing.core/map-vals, :variadic false, :file "resources/public/js/compiled/out/plumbing/core.cljs", :end-column 15, :method-params ([f m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil clj any}, :variadic false, :max-fixed-arity 2}), :line 66, :end-line 66, :max-fixed-arity 2, :fn-var true, :arglists (quote ([f m])), :doc "Build map k -> (f v) for [k v] in map, preserving the initial type", :test true}, assoc-when {:protocol-inline nil, :meta {:arglists (quote ([m & kvs])), :doc "Like assoc but only assocs when value is truthy", :end-column 17, :end-line 141, :column 7, :line 141, :file "/Users/adam/Copy/play/clj/outliner/resources/public/js/compiled/out/plumbing/core.cljs"}, :name plumbing.core/assoc-when, :variadic true, :file "resources/public/js/compiled/out/plumbing/core.cljs", :end-column 17, :method-params ([m kvs]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil clj any cljs.core/MetaFn clj-nil}, :variadic true, :max-fixed-arity 1}), :line 141, :end-line 141, :max-fixed-arity 1, :fn-var true, :arglists (quote ([m & kvs])), :doc "Like assoc but only assocs when value is truthy", :test true}, map-from-vals {:protocol-inline nil, :meta {:arglists (quote ([f vs])), :doc "Build map (f v) -> v for vals in vs", :end-column 20, :end-line 89, :column 7, :line 89, :file "/Users/adam/Copy/play/clj/outliner/resources/public/js/compiled/out/plumbing/core.cljs"}, :name plumbing.core/map-from-vals, :variadic false, :file "resources/public/js/compiled/out/plumbing/core.cljs", :end-column 20, :method-params ([f vs]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag clj, :variadic false, :max-fixed-arity 2}), :line 89, :end-line 89, :max-fixed-arity 2, :fn-var true, :arglists (quote ([f vs])), :doc "Build map (f v) -> v for vals in vs", :test true}, update-in-when {:protocol-inline nil, :meta {:arglists (quote ([m key-seq f & args])), :doc "Like update-in but returns m unchanged if key-seq is not present.", :end-column 21, :end-line 150, :column 7, :line 150, :file "/Users/adam/Copy/play/clj/outliner/resources/public/js/compiled/out/plumbing/core.cljs"}, :name plumbing.core/update-in-when, :variadic true, :file "resources/public/js/compiled/out/plumbing/core.cljs", :end-column 21, :method-params ([m key-seq f args]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{nil clj}, :variadic true, :max-fixed-arity 3}), :line 150, :end-line 150, :max-fixed-arity 3, :fn-var true, :arglists (quote ([m key-seq f & args])), :doc "Like update-in but returns m unchanged if key-seq is not present.", :test true}, unchunk {:protocol-inline nil, :meta {:arglists (quote ([s])), :doc "Takes a seqable and returns a lazy sequence that\n   is maximally lazy and doesn't realize elements due to either\n   chunking or apply.\n\n   Useful when you don't want chunking, for instance,\n   (first awesome-website? (map slurp +a-bunch-of-urls+))\n   may slurp up to 31 unneed webpages, wherease\n   (first awesome-website? (map slurp (unchunk +a-bunch-of-urls+)))\n   is guaranteed to stop slurping after the first awesome website.\n\n  Taken from http://stackoverflow.com/questions/3407876/how-do-i-avoid-clojures-chunking-behavior-for-lazy-seqs-that-i-want-to-short-ci", :end-column 14, :end-line 178, :column 7, :line 178, :file "/Users/adam/Copy/play/clj/outliner/resources/public/js/compiled/out/plumbing/core.cljs"}, :name plumbing.core/unchunk, :variadic false, :file "resources/public/js/compiled/out/plumbing/core.cljs", :end-column 14, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{cljs.core/Cons clj-nil}, :variadic false, :max-fixed-arity 1}), :line 178, :end-line 178, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s])), :doc "Takes a seqable and returns a lazy sequence that\n   is maximally lazy and doesn't realize elements due to either\n   chunking or apply.\n\n   Useful when you don't want chunking, for instance,\n   (first awesome-website? (map slurp +a-bunch-of-urls+))\n   may slurp up to 31 unneed webpages, wherease\n   (first awesome-website? (map slurp (unchunk +a-bunch-of-urls+)))\n   is guaranteed to stop slurping after the first awesome website.\n\n  Taken from http://stackoverflow.com/questions/3407876/how-do-i-avoid-clojures-chunking-behavior-for-lazy-seqs-that-i-want-to-short-ci", :test true}, safe-get {:protocol-inline nil, :meta {:arglists (quote ([m k])), :doc "Like get but throw an exception if not found", :end-column 15, :end-line 127, :column 7, :line 127, :file "/Users/adam/Copy/play/clj/outliner/resources/public/js/compiled/out/plumbing/core.cljs"}, :name plumbing.core/safe-get, :variadic false, :file "resources/public/js/compiled/out/plumbing/core.cljs", :end-column 15, :method-params ([m k]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :methods ({:tag #{any clj-nil}, :variadic false, :max-fixed-arity 2}), :line 127, :end-line 127, :max-fixed-arity 2, :fn-var true, :arglists (quote ([m k])), :doc "Like get but throw an exception if not found", :test true}}, :require-macros {schema plumbing.fnk.schema, plumbing.fnk.schema plumbing.fnk.schema, schema.macros schema.macros, plumbing.core plumbing.core}, :cljs.analyzer/constants {:order [:plumbing.core/missing :else], :seen #{:plumbing.core/missing :else}}, :doc "Utility belt for Clojure in the wild"}